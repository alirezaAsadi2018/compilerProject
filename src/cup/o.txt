===== Viable Prefix Recognizer =====
START lalr_state [0]: {
  [prog ::= (*) struct_dcl , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [func_dcl ::= (*) FUNCTION type ID OPENPAR args CLOSEPAR block , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [type ::= (*) CHAR , {ID }]
  [type ::= (*) AUTO , {ID }]
  [dcl ::= (*) type commadcls SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [prog ::= (*) dcl , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [func_dcl ::= (*) FUNCTION type ID OPENPAR args CLOSEPAR SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [type ::= (*) FLOAT , {ID }]
  [type ::= (*) STRING , {ID }]
  [program ::= (*) prog program , {EOF }]
  [func_extern ::= (*) func_dcl , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [func_dcl ::= (*) FUNCTION type ID OPENPAR CLOSEPAR block , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [type ::= (*) INT , {ID }]
  [type ::= (*) DOUBLE , {ID }]
  [extern_dcl ::= (*) EXTERN type ID SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [dcl ::= (*) CONST type commadcls SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [prog ::= (*) func_extern , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [func_dcl ::= (*) FUNCTION type ID OPENPAR CLOSEPAR SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [type ::= (*) LONG , {ID }]
  [type ::= (*) VOID , {ID }]
  [program ::= (*) prog , {EOF }]
  [func_extern ::= (*) extern_dcl , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [type ::= (*) BOOL , {ID }]
  [type ::= (*) ID , {ID }]
  [struct_dcl ::= (*) RECORD ID BEGIN dcls END RECORD SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [$START ::= (*) program EOF , {EOF }]
}
transition on DOUBLE to state [22]
transition on VOID to state [21]
transition on BOOL to state [20]
transition on func_extern to state [19]
transition on dcl to state [18]
transition on CONST to state [17]
transition on RECORD to state [16]
transition on AUTO to state [15]
transition on FLOAT to state [14]
transition on STRING to state [13]
transition on ID to state [12]
transition on program to state [11]
transition on func_dcl to state [10]
transition on prog to state [9]
transition on FUNCTION to state [8]
transition on struct_dcl to state [7]
transition on type to state [6]
transition on CHAR to state [5]
transition on extern_dcl to state [4]
transition on INT to state [3]
transition on LONG to state [2]
transition on EXTERN to state [1]

-------------------
lalr_state [1]: {
  [type ::= (*) CHAR , {ID }]
  [type ::= (*) BOOL , {ID }]
  [type ::= (*) AUTO , {ID }]
  [type ::= (*) ID , {ID }]
  [type ::= (*) LONG , {ID }]
  [type ::= (*) INT , {ID }]
  [type ::= (*) VOID , {ID }]
  [type ::= (*) DOUBLE , {ID }]
  [type ::= (*) FLOAT , {ID }]
  [extern_dcl ::= EXTERN (*) type ID SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [type ::= (*) STRING , {ID }]
}
transition on CHAR to state [5]
transition on FLOAT to state [14]
transition on AUTO to state [15]
transition on type to state [232]
transition on ID to state [12]
transition on DOUBLE to state [22]
transition on STRING to state [13]
transition on VOID to state [21]
transition on BOOL to state [20]
transition on LONG to state [2]
transition on INT to state [3]

-------------------
lalr_state [2]: {
  [type ::= LONG (*) , {ID CLOSEPAR }]
}

-------------------
lalr_state [3]: {
  [type ::= INT (*) , {ID CLOSEPAR }]
}

-------------------
lalr_state [4]: {
  [func_extern ::= extern_dcl (*) , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
}

-------------------
lalr_state [5]: {
  [type ::= CHAR (*) , {ID CLOSEPAR }]
}

-------------------
lalr_state [6]: {
  [dcl_cnt ::= (*) ID EQ expr , {COMMA SEMCOLON }]
  [commadcls ::= (*) dcl_cnt COMMA commadcls , {SEMCOLON }]
  [dcl_cnt ::= (*) ID , {COMMA SEMCOLON }]
  [dcl_cnt ::= (*) ID array , {COMMA SEMCOLON }]
  [commadcls ::= (*) dcl_cnt , {SEMCOLON }]
  [dcl ::= type (*) commadcls SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on dcl_cnt to state [26]
transition on commadcls to state [230]
transition on ID to state [24]

-------------------
lalr_state [7]: {
  [prog ::= struct_dcl (*) , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
}

-------------------
lalr_state [8]: {
  [type ::= (*) CHAR , {ID }]
  [type ::= (*) BOOL , {ID }]
  [func_dcl ::= FUNCTION (*) type ID OPENPAR CLOSEPAR block , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [func_dcl ::= FUNCTION (*) type ID OPENPAR args CLOSEPAR SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [type ::= (*) AUTO , {ID }]
  [type ::= (*) ID , {ID }]
  [type ::= (*) LONG , {ID }]
  [type ::= (*) INT , {ID }]
  [func_dcl ::= FUNCTION (*) type ID OPENPAR args CLOSEPAR block , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [type ::= (*) VOID , {ID }]
  [type ::= (*) DOUBLE , {ID }]
  [type ::= (*) FLOAT , {ID }]
  [func_dcl ::= FUNCTION (*) type ID OPENPAR CLOSEPAR SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [type ::= (*) STRING , {ID }]
}
transition on CHAR to state [5]
transition on FLOAT to state [14]
transition on AUTO to state [15]
transition on type to state [110]
transition on ID to state [12]
transition on DOUBLE to state [22]
transition on STRING to state [13]
transition on VOID to state [21]
transition on BOOL to state [20]
transition on LONG to state [2]
transition on INT to state [3]

-------------------
lalr_state [9]: {
  [prog ::= (*) struct_dcl , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [func_dcl ::= (*) FUNCTION type ID OPENPAR args CLOSEPAR block , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [type ::= (*) CHAR , {ID }]
  [type ::= (*) AUTO , {ID }]
  [dcl ::= (*) type commadcls SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [prog ::= (*) dcl , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [func_dcl ::= (*) FUNCTION type ID OPENPAR args CLOSEPAR SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [type ::= (*) FLOAT , {ID }]
  [type ::= (*) STRING , {ID }]
  [program ::= prog (*) program , {EOF }]
  [program ::= (*) prog program , {EOF }]
  [func_extern ::= (*) func_dcl , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [func_dcl ::= (*) FUNCTION type ID OPENPAR CLOSEPAR block , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [type ::= (*) INT , {ID }]
  [type ::= (*) DOUBLE , {ID }]
  [extern_dcl ::= (*) EXTERN type ID SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [dcl ::= (*) CONST type commadcls SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [prog ::= (*) func_extern , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [func_dcl ::= (*) FUNCTION type ID OPENPAR CLOSEPAR SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [type ::= (*) LONG , {ID }]
  [type ::= (*) VOID , {ID }]
  [program ::= prog (*) , {EOF }]
  [program ::= (*) prog , {EOF }]
  [func_extern ::= (*) extern_dcl , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [type ::= (*) BOOL , {ID }]
  [type ::= (*) ID , {ID }]
  [struct_dcl ::= (*) RECORD ID BEGIN dcls END RECORD SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
}
transition on DOUBLE to state [22]
transition on VOID to state [21]
transition on BOOL to state [20]
transition on func_extern to state [19]
transition on dcl to state [18]
transition on CONST to state [17]
transition on RECORD to state [16]
transition on AUTO to state [15]
transition on FLOAT to state [14]
transition on STRING to state [13]
transition on ID to state [12]
transition on program to state [109]
transition on func_dcl to state [10]
transition on prog to state [9]
transition on FUNCTION to state [8]
transition on struct_dcl to state [7]
transition on type to state [6]
transition on CHAR to state [5]
transition on extern_dcl to state [4]
transition on INT to state [3]
transition on LONG to state [2]
transition on EXTERN to state [1]

-------------------
lalr_state [10]: {
  [func_extern ::= func_dcl (*) , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
}

-------------------
lalr_state [11]: {
  [$START ::= program (*) EOF , {EOF }]
}
transition on EOF to state [108]

-------------------
lalr_state [12]: {
  [type ::= ID (*) , {ID CLOSEPAR }]
}

-------------------
lalr_state [13]: {
  [type ::= STRING (*) , {ID CLOSEPAR }]
}

-------------------
lalr_state [14]: {
  [type ::= FLOAT (*) , {ID CLOSEPAR }]
}

-------------------
lalr_state [15]: {
  [type ::= AUTO (*) , {ID CLOSEPAR }]
}

-------------------
lalr_state [16]: {
  [struct_dcl ::= RECORD (*) ID BEGIN dcls END RECORD SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
}
transition on ID to state [100]

-------------------
lalr_state [17]: {
  [type ::= (*) CHAR , {ID }]
  [type ::= (*) BOOL , {ID }]
  [dcl ::= CONST (*) type commadcls SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [type ::= (*) AUTO , {ID }]
  [type ::= (*) ID , {ID }]
  [type ::= (*) LONG , {ID }]
  [type ::= (*) INT , {ID }]
  [type ::= (*) VOID , {ID }]
  [type ::= (*) DOUBLE , {ID }]
  [type ::= (*) FLOAT , {ID }]
  [type ::= (*) STRING , {ID }]
}
transition on CHAR to state [5]
transition on FLOAT to state [14]
transition on AUTO to state [15]
transition on type to state [23]
transition on ID to state [12]
transition on DOUBLE to state [22]
transition on STRING to state [13]
transition on VOID to state [21]
transition on BOOL to state [20]
transition on LONG to state [2]
transition on INT to state [3]

-------------------
lalr_state [18]: {
  [prog ::= dcl (*) , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
}

-------------------
lalr_state [19]: {
  [prog ::= func_extern (*) , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
}

-------------------
lalr_state [20]: {
  [type ::= BOOL (*) , {ID CLOSEPAR }]
}

-------------------
lalr_state [21]: {
  [type ::= VOID (*) , {ID CLOSEPAR }]
}

-------------------
lalr_state [22]: {
  [type ::= DOUBLE (*) , {ID CLOSEPAR }]
}

-------------------
lalr_state [23]: {
  [dcl_cnt ::= (*) ID EQ expr , {COMMA SEMCOLON }]
  [commadcls ::= (*) dcl_cnt COMMA commadcls , {SEMCOLON }]
  [dcl ::= CONST type (*) commadcls SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [dcl_cnt ::= (*) ID , {COMMA SEMCOLON }]
  [dcl_cnt ::= (*) ID array , {COMMA SEMCOLON }]
  [commadcls ::= (*) dcl_cnt , {SEMCOLON }]
}
transition on dcl_cnt to state [26]
transition on commadcls to state [25]
transition on ID to state [24]

-------------------
lalr_state [24]: {
  [dcl_cnt ::= ID (*) EQ expr , {COMMA SEMCOLON }]
  [array ::= (*) OPENBRAC expr CLOSEBRAC array , {COMMA SEMCOLON }]
  [dcl_cnt ::= ID (*) , {COMMA SEMCOLON }]
  [dcl_cnt ::= ID (*) array , {COMMA SEMCOLON }]
  [array ::= (*) OPENBRAC expr CLOSEBRAC , {COMMA SEMCOLON }]
}
transition on array to state [32]
transition on EQ to state [31]
transition on OPENBRAC to state [30]

-------------------
lalr_state [25]: {
  [dcl ::= CONST type commadcls (*) SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on SEMCOLON to state [29]

-------------------
lalr_state [26]: {
  [commadcls ::= dcl_cnt (*) COMMA commadcls , {SEMCOLON }]
  [commadcls ::= dcl_cnt (*) , {SEMCOLON }]
}
transition on COMMA to state [27]

-------------------
lalr_state [27]: {
  [commadcls ::= dcl_cnt COMMA (*) commadcls , {SEMCOLON }]
  [dcl_cnt ::= (*) ID EQ expr , {COMMA SEMCOLON }]
  [commadcls ::= (*) dcl_cnt COMMA commadcls , {SEMCOLON }]
  [dcl_cnt ::= (*) ID , {COMMA SEMCOLON }]
  [dcl_cnt ::= (*) ID array , {COMMA SEMCOLON }]
  [commadcls ::= (*) dcl_cnt , {SEMCOLON }]
}
transition on dcl_cnt to state [26]
transition on commadcls to state [28]
transition on ID to state [24]

-------------------
lalr_state [28]: {
  [commadcls ::= dcl_cnt COMMA commadcls (*) , {SEMCOLON }]
}

-------------------
lalr_state [29]: {
  [dcl ::= CONST type commadcls SEMCOLON (*) , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}

-------------------
lalr_state [30]: {
  [expr ::= (*) expr OR expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [array ::= OPENBRAC (*) expr CLOSEBRAC array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA EQ PLUSEQ MINUSEQ MULTEQ DIVEQ IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [array ::= OPENBRAC (*) expr CLOSEBRAC , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA EQ PLUSEQ MINUSEQ MULTEQ DIVEQ IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [97]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [31]: {
  [expr ::= (*) expr OR expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {COMMA SEMCOLON DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {COMMA SEMCOLON DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {COMMA SEMCOLON DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [dcl_cnt ::= ID EQ (*) expr , {COMMA SEMCOLON }]
  [const_val ::= (*) INT_CONST , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [48]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [32]: {
  [dcl_cnt ::= ID array (*) , {COMMA SEMCOLON }]
}

-------------------
lalr_state [33]: {
  [const_val ::= LONG_CONST (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}

-------------------
lalr_state [34]: {
  [expr ::= (*) expr OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= MINUS (*) expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [96]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [35]: {
  [const_val ::= REAL_CONST (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}

-------------------
lalr_state [36]: {
  [expr ::= const_val (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}

-------------------
lalr_state [37]: {
  [expr ::= SIZEOF (*) OPENPAR type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OPENPAR to state [93]

-------------------
lalr_state [38]: {
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= PLUSPLUS (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on variable to state [92]
transition on ID to state [45]

-------------------
lalr_state [39]: {
  [const_val ::= INT_CONST (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}

-------------------
lalr_state [40]: {
  [expr ::= (*) expr OR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= OPENPAR (*) expr CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [90]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [41]: {
  [const_val ::= STRING_CONST (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}

-------------------
lalr_state [42]: {
  [variable ::= variable (*) DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= variable (*) PLUSPLUS , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= variable (*) MINMIN , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= variable (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on DOT to state [51]
transition on PLUSPLUS to state [89]
transition on MINMIN to state [88]

-------------------
lalr_state [43]: {
  [expr ::= (*) expr OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= TILDE (*) expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [87]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [44]: {
  [const_val ::= BOOL_CONST (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}

-------------------
lalr_state [45]: {
  [array ::= (*) OPENBRAC expr CLOSEBRAC array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA EQ PLUSEQ MINUSEQ MULTEQ DIVEQ IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= ID (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA EQ PLUSEQ MINUSEQ MULTEQ DIVEQ IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= ID (*) array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA EQ PLUSEQ MINUSEQ MULTEQ DIVEQ IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [array ::= (*) OPENBRAC expr CLOSEBRAC , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA EQ PLUSEQ MINUSEQ MULTEQ DIVEQ IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on array to state [86]
transition on OPENBRAC to state [30]

-------------------
lalr_state [46]: {
  [const_val ::= CHAR_CONST (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}

-------------------
lalr_state [47]: {
  [expr ::= (*) expr OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= NOT (*) expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [85]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [48]: {
  [expr ::= expr (*) OR expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [dcl_cnt ::= ID EQ expr (*) , {COMMA SEMCOLON }]
  [expr ::= expr (*) LT expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {COMMA SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [49]: {
  [expr ::= MINMIN (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on variable to state [50]
transition on ID to state [45]

-------------------
lalr_state [50]: {
  [variable ::= variable (*) DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= MINMIN variable (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on DOT to state [51]

-------------------
lalr_state [51]: {
  [variable ::= variable DOT (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA EQ PLUSEQ MINUSEQ MULTEQ DIVEQ IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on ID to state [52]

-------------------
lalr_state [52]: {
  [variable ::= variable DOT ID (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA EQ PLUSEQ MINUSEQ MULTEQ DIVEQ IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}

-------------------
lalr_state [53]: {
  [expr ::= (*) expr OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr MINUS (*) expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [84]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [54]: {
  [expr ::= (*) expr OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr ARITAND (*) expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [83]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [55]: {
  [expr ::= (*) expr OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr AND (*) expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [82]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [56]: {
  [expr ::= (*) expr OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr XOR (*) expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [81]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [57]: {
  [expr ::= (*) expr OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr EQEQ (*) expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [80]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [58]: {
  [expr ::= (*) expr OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr GTEQ (*) expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [79]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [59]: {
  [expr ::= (*) expr OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr MULT (*) expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [78]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [60]: {
  [expr ::= (*) expr OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr MOD (*) expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [77]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [61]: {
  [expr ::= (*) expr OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr INEQ (*) expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [76]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [62]: {
  [expr ::= (*) expr OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr PLUS (*) expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [75]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [63]: {
  [expr ::= (*) expr OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr DIV (*) expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [74]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [64]: {
  [expr ::= (*) expr OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr GT (*) expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [73]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [65]: {
  [expr ::= (*) expr OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr ARITOR (*) expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [72]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [66]: {
  [expr ::= (*) expr OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr LT (*) expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [71]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [67]: {
  [expr ::= (*) expr OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr LTEQ (*) expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [70]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [68]: {
  [expr ::= (*) expr OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr OR (*) expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [69]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [69]: {
  [expr ::= expr (*) OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr OR expr (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [70]: {
  [expr ::= expr (*) OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr LTEQ expr (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [71]: {
  [expr ::= expr (*) OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr LT expr (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [72]: {
  [expr ::= expr (*) OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr ARITOR expr (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [73]: {
  [expr ::= expr (*) OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr GT expr (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [74]: {
  [expr ::= expr (*) OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr DIV expr (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [75]: {
  [expr ::= expr (*) OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr PLUS expr (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [76]: {
  [expr ::= expr INEQ expr (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [77]: {
  [expr ::= expr (*) OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr MOD expr (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [78]: {
  [expr ::= expr (*) OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr MULT expr (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [79]: {
  [expr ::= expr (*) OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr GTEQ expr (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [80]: {
  [expr ::= expr (*) OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr EQEQ expr (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [81]: {
  [expr ::= expr (*) OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr XOR expr (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [82]: {
  [expr ::= expr (*) OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr AND expr (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [83]: {
  [expr ::= expr (*) OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr ARITAND expr (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [84]: {
  [expr ::= expr (*) OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr MINUS expr (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [85]: {
  [expr ::= expr (*) OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= NOT expr (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [86]: {
  [variable ::= ID array (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA EQ PLUSEQ MINUSEQ MULTEQ DIVEQ IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}

-------------------
lalr_state [87]: {
  [expr ::= expr (*) OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= TILDE expr (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [88]: {
  [expr ::= variable MINMIN (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}

-------------------
lalr_state [89]: {
  [expr ::= variable PLUSPLUS (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}

-------------------
lalr_state [90]: {
  [expr ::= expr (*) OR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= OPENPAR expr (*) CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on CLOSEPAR to state [91]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [91]: {
  [expr ::= OPENPAR expr CLOSEPAR (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}

-------------------
lalr_state [92]: {
  [variable ::= variable (*) DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= PLUSPLUS variable (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on DOT to state [51]

-------------------
lalr_state [93]: {
  [type ::= (*) CHAR , {CLOSEPAR }]
  [type ::= (*) BOOL , {CLOSEPAR }]
  [type ::= (*) AUTO , {CLOSEPAR }]
  [type ::= (*) ID , {CLOSEPAR }]
  [type ::= (*) LONG , {CLOSEPAR }]
  [type ::= (*) INT , {CLOSEPAR }]
  [type ::= (*) VOID , {CLOSEPAR }]
  [type ::= (*) DOUBLE , {CLOSEPAR }]
  [type ::= (*) FLOAT , {CLOSEPAR }]
  [expr ::= SIZEOF OPENPAR (*) type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [type ::= (*) STRING , {CLOSEPAR }]
}
transition on CHAR to state [5]
transition on FLOAT to state [14]
transition on AUTO to state [15]
transition on type to state [94]
transition on ID to state [12]
transition on DOUBLE to state [22]
transition on STRING to state [13]
transition on VOID to state [21]
transition on BOOL to state [20]
transition on LONG to state [2]
transition on INT to state [3]

-------------------
lalr_state [94]: {
  [expr ::= SIZEOF OPENPAR type (*) CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on CLOSEPAR to state [95]

-------------------
lalr_state [95]: {
  [expr ::= SIZEOF OPENPAR type CLOSEPAR (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}

-------------------
lalr_state [96]: {
  [expr ::= expr (*) OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= MINUS expr (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [97]: {
  [expr ::= expr (*) MINUS expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [array ::= OPENBRAC expr (*) CLOSEBRAC array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA EQ PLUSEQ MINUSEQ MULTEQ DIVEQ IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) OR expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {CLOSEBRAC PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [array ::= OPENBRAC expr (*) CLOSEBRAC , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA EQ PLUSEQ MINUSEQ MULTEQ DIVEQ IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on CLOSEBRAC to state [98]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on XOR to state [56]
transition on EQEQ to state [57]
transition on AND to state [55]
transition on MINUS to state [53]
transition on ARITAND to state [54]

-------------------
lalr_state [98]: {
  [array ::= OPENBRAC expr CLOSEBRAC (*) array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA EQ PLUSEQ MINUSEQ MULTEQ DIVEQ IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [array ::= (*) OPENBRAC expr CLOSEBRAC array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA EQ PLUSEQ MINUSEQ MULTEQ DIVEQ IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [array ::= OPENBRAC expr CLOSEBRAC (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA EQ PLUSEQ MINUSEQ MULTEQ DIVEQ IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [array ::= (*) OPENBRAC expr CLOSEBRAC , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA EQ PLUSEQ MINUSEQ MULTEQ DIVEQ IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on array to state [99]
transition on OPENBRAC to state [30]

-------------------
lalr_state [99]: {
  [array ::= OPENBRAC expr CLOSEBRAC array (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE COMMA EQ PLUSEQ MINUSEQ MULTEQ DIVEQ IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR CLOSEBRAC DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}

-------------------
lalr_state [100]: {
  [struct_dcl ::= RECORD ID (*) BEGIN dcls END RECORD SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
}
transition on BEGIN to state [101]

-------------------
lalr_state [101]: {
  [type ::= (*) CHAR , {ID }]
  [type ::= (*) BOOL , {ID }]
  [dcl ::= (*) CONST type commadcls SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST END }]
  [dcls ::= (*) dcl dcls , {END }]
  [type ::= (*) AUTO , {ID }]
  [type ::= (*) ID , {ID }]
  [type ::= (*) LONG , {ID }]
  [type ::= (*) INT , {ID }]
  [struct_dcl ::= RECORD ID BEGIN (*) dcls END RECORD SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [dcl ::= (*) type commadcls SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST END }]
  [type ::= (*) VOID , {ID }]
  [type ::= (*) DOUBLE , {ID }]
  [type ::= (*) FLOAT , {ID }]
  [dcls ::= (*) dcl , {END }]
  [type ::= (*) STRING , {ID }]
}
transition on CONST to state [17]
transition on CHAR to state [5]
transition on FLOAT to state [14]
transition on AUTO to state [15]
transition on dcls to state [103]
transition on type to state [6]
transition on ID to state [12]
transition on dcl to state [102]
transition on DOUBLE to state [22]
transition on STRING to state [13]
transition on VOID to state [21]
transition on BOOL to state [20]
transition on LONG to state [2]
transition on INT to state [3]

-------------------
lalr_state [102]: {
  [type ::= (*) CHAR , {ID }]
  [type ::= (*) BOOL , {ID }]
  [dcls ::= dcl (*) dcls , {END }]
  [dcl ::= (*) CONST type commadcls SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST END }]
  [dcls ::= (*) dcl dcls , {END }]
  [type ::= (*) AUTO , {ID }]
  [type ::= (*) ID , {ID }]
  [type ::= (*) LONG , {ID }]
  [type ::= (*) INT , {ID }]
  [dcl ::= (*) type commadcls SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST END }]
  [type ::= (*) VOID , {ID }]
  [type ::= (*) DOUBLE , {ID }]
  [type ::= (*) FLOAT , {ID }]
  [dcls ::= dcl (*) , {END }]
  [dcls ::= (*) dcl , {END }]
  [type ::= (*) STRING , {ID }]
}
transition on CONST to state [17]
transition on CHAR to state [5]
transition on FLOAT to state [14]
transition on AUTO to state [15]
transition on dcls to state [107]
transition on type to state [6]
transition on ID to state [12]
transition on dcl to state [102]
transition on DOUBLE to state [22]
transition on STRING to state [13]
transition on VOID to state [21]
transition on BOOL to state [20]
transition on LONG to state [2]
transition on INT to state [3]

-------------------
lalr_state [103]: {
  [struct_dcl ::= RECORD ID BEGIN dcls (*) END RECORD SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
}
transition on END to state [104]

-------------------
lalr_state [104]: {
  [struct_dcl ::= RECORD ID BEGIN dcls END (*) RECORD SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
}
transition on RECORD to state [105]

-------------------
lalr_state [105]: {
  [struct_dcl ::= RECORD ID BEGIN dcls END RECORD (*) SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
}
transition on SEMCOLON to state [106]

-------------------
lalr_state [106]: {
  [struct_dcl ::= RECORD ID BEGIN dcls END RECORD SEMCOLON (*) , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
}

-------------------
lalr_state [107]: {
  [dcls ::= dcl dcls (*) , {END }]
}

-------------------
lalr_state [108]: {
  [$START ::= program EOF (*) , {EOF }]
}

-------------------
lalr_state [109]: {
  [program ::= prog program (*) , {EOF }]
}

-------------------
lalr_state [110]: {
  [func_dcl ::= FUNCTION type (*) ID OPENPAR args CLOSEPAR block , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [func_dcl ::= FUNCTION type (*) ID OPENPAR CLOSEPAR SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [func_dcl ::= FUNCTION type (*) ID OPENPAR CLOSEPAR block , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [func_dcl ::= FUNCTION type (*) ID OPENPAR args CLOSEPAR SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
}
transition on ID to state [111]

-------------------
lalr_state [111]: {
  [func_dcl ::= FUNCTION type ID (*) OPENPAR args CLOSEPAR block , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [func_dcl ::= FUNCTION type ID (*) OPENPAR CLOSEPAR SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [func_dcl ::= FUNCTION type ID (*) OPENPAR CLOSEPAR block , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [func_dcl ::= FUNCTION type ID (*) OPENPAR args CLOSEPAR SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
}
transition on OPENPAR to state [112]

-------------------
lalr_state [112]: {
  [type ::= (*) CHAR , {ID }]
  [func_dcl ::= FUNCTION type ID OPENPAR (*) args CLOSEPAR SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [type ::= (*) BOOL , {ID }]
  [type ::= (*) AUTO , {ID }]
  [type ::= (*) ID , {ID }]
  [func_dcl ::= FUNCTION type ID OPENPAR (*) args CLOSEPAR block , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [type ::= (*) LONG , {ID }]
  [type ::= (*) INT , {ID }]
  [args ::= (*) type ID argarray COMMA args , {CLOSEPAR }]
  [type ::= (*) VOID , {ID }]
  [func_dcl ::= FUNCTION type ID OPENPAR (*) CLOSEPAR SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [type ::= (*) DOUBLE , {ID }]
  [type ::= (*) FLOAT , {ID }]
  [args ::= (*) type ID argarray , {CLOSEPAR }]
  [type ::= (*) STRING , {ID }]
  [func_dcl ::= FUNCTION type ID OPENPAR (*) CLOSEPAR block , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
}
transition on CHAR to state [5]
transition on FLOAT to state [14]
transition on AUTO to state [15]
transition on type to state [115]
transition on ID to state [12]
transition on args to state [114]
transition on DOUBLE to state [22]
transition on STRING to state [13]
transition on VOID to state [21]
transition on CLOSEPAR to state [113]
transition on BOOL to state [20]
transition on LONG to state [2]
transition on INT to state [3]

-------------------
lalr_state [113]: {
  [func_dcl ::= FUNCTION type ID OPENPAR CLOSEPAR (*) SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [block ::= (*) BEGIN dclst END , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [func_dcl ::= FUNCTION type ID OPENPAR CLOSEPAR (*) block , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
}
transition on block to state [229]
transition on SEMCOLON to state [228]
transition on BEGIN to state [125]

-------------------
lalr_state [114]: {
  [func_dcl ::= FUNCTION type ID OPENPAR args (*) CLOSEPAR SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [func_dcl ::= FUNCTION type ID OPENPAR args (*) CLOSEPAR block , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
}
transition on CLOSEPAR to state [123]

-------------------
lalr_state [115]: {
  [args ::= type (*) ID argarray COMMA args , {CLOSEPAR }]
  [args ::= type (*) ID argarray , {CLOSEPAR }]
}
transition on ID to state [116]

-------------------
lalr_state [116]: {
  [args ::= type ID (*) argarray COMMA args , {CLOSEPAR }]
  [args ::= type ID (*) argarray , {CLOSEPAR }]
  [argarray ::= (*) , {COMMA CLOSEPAR }]
  [argarray ::= (*) OPENBRAC CLOSEBRAC argarray , {COMMA CLOSEPAR }]
}
transition on argarray to state [118]
transition on OPENBRAC to state [117]

-------------------
lalr_state [117]: {
  [argarray ::= OPENBRAC (*) CLOSEBRAC argarray , {COMMA CLOSEPAR }]
}
transition on CLOSEBRAC to state [121]

-------------------
lalr_state [118]: {
  [args ::= type ID argarray (*) , {CLOSEPAR }]
  [args ::= type ID argarray (*) COMMA args , {CLOSEPAR }]
}
transition on COMMA to state [119]

-------------------
lalr_state [119]: {
  [type ::= (*) CHAR , {ID }]
  [type ::= (*) BOOL , {ID }]
  [type ::= (*) AUTO , {ID }]
  [args ::= type ID argarray COMMA (*) args , {CLOSEPAR }]
  [type ::= (*) ID , {ID }]
  [type ::= (*) LONG , {ID }]
  [type ::= (*) INT , {ID }]
  [args ::= (*) type ID argarray COMMA args , {CLOSEPAR }]
  [type ::= (*) VOID , {ID }]
  [type ::= (*) DOUBLE , {ID }]
  [type ::= (*) FLOAT , {ID }]
  [args ::= (*) type ID argarray , {CLOSEPAR }]
  [type ::= (*) STRING , {ID }]
}
transition on CHAR to state [5]
transition on FLOAT to state [14]
transition on AUTO to state [15]
transition on type to state [115]
transition on ID to state [12]
transition on args to state [120]
transition on DOUBLE to state [22]
transition on STRING to state [13]
transition on VOID to state [21]
transition on BOOL to state [20]
transition on LONG to state [2]
transition on INT to state [3]

-------------------
lalr_state [120]: {
  [args ::= type ID argarray COMMA args (*) , {CLOSEPAR }]
}

-------------------
lalr_state [121]: {
  [argarray ::= (*) , {COMMA CLOSEPAR }]
  [argarray ::= OPENBRAC CLOSEBRAC (*) argarray , {COMMA CLOSEPAR }]
  [argarray ::= (*) OPENBRAC CLOSEBRAC argarray , {COMMA CLOSEPAR }]
}
transition on argarray to state [122]
transition on OPENBRAC to state [117]

-------------------
lalr_state [122]: {
  [argarray ::= OPENBRAC CLOSEBRAC argarray (*) , {COMMA CLOSEPAR }]
}

-------------------
lalr_state [123]: {
  [block ::= (*) BEGIN dclst END , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [func_dcl ::= FUNCTION type ID OPENPAR args CLOSEPAR (*) SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
  [func_dcl ::= FUNCTION type ID OPENPAR args CLOSEPAR (*) block , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
}
transition on block to state [126]
transition on BEGIN to state [125]
transition on SEMCOLON to state [124]

-------------------
lalr_state [124]: {
  [func_dcl ::= FUNCTION type ID OPENPAR args CLOSEPAR SEMCOLON (*) , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
}

-------------------
lalr_state [125]: {
  [assignment ::= (*) variable MINUSEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= (*) FOR OPENPAR assignment SEMCOLON expr SEMCOLON assignment CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [method_call ::= (*) ID OPENPAR CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [st ::= (*) method_call , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [type ::= (*) STRING , {ID }]
  [variable ::= (*) ID , {EQ PLUSEQ MINUSEQ MULTEQ DIVEQ DOT }]
  [loop_st ::= (*) REPEAT block UNTIL OPENPAR expr CLOSEPAR SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [cond_st ::= (*) SWITCH OPENPAR expr CLOSEPAR OF COLON BEGIN cases DEFAULT COLON block END , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [block ::= BEGIN (*) dclst END , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD RETURN BREAK CONTINUE IF ELSE SWITCH END DEFAULT CASE FOR REPEAT UNTIL FOREACH }]
  [st ::= (*) RETURN SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [type ::= (*) LONG , {ID }]
  [assignment ::= (*) variable MULTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= (*) FOR OPENPAR assignment SEMCOLON expr SEMCOLON CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [st ::= (*) assignment , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [type ::= (*) VOID , {ID }]
  [variable ::= (*) variable DOT ID , {EQ PLUSEQ MINUSEQ MULTEQ DIVEQ DOT }]
  [loop_st ::= (*) FOREACH OPENPAR ID IN ID CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [st ::= (*) BREAK SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [dclst ::= (*) dcl dclst , {END }]
  [type ::= (*) CHAR , {ID }]
  [assignment ::= (*) variable DIVEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= (*) FOR OPENPAR SEMCOLON expr SEMCOLON expr CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [st ::= (*) cond_st , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [type ::= (*) AUTO , {ID }]
  [type ::= (*) INT , {ID }]
  [variable ::= (*) ID array , {EQ PLUSEQ MINUSEQ MULTEQ DIVEQ DOT }]
  [assignment ::= (*) variable EQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [st ::= (*) CONTINUE SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [dclst ::= (*) st dclst , {END }]
  [dcl ::= (*) type commadcls SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [type ::= (*) DOUBLE , {ID }]
  [loop_st ::= (*) FOR OPENPAR SEMCOLON expr SEMCOLON assignment CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [cond_st ::= (*) IF OPENPAR expr CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [st ::= (*) loop_st , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [type ::= (*) BOOL , {ID }]
  [assignment ::= (*) variable PLUSEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= (*) FOR OPENPAR assignment SEMCOLON expr SEMCOLON expr CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [method_call ::= (*) ID OPENPAR params CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [dclst ::= (*) , {END }]
  [dcl ::= (*) CONST type commadcls SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [type ::= (*) ID , {ID }]
  [loop_st ::= (*) FOR OPENPAR SEMCOLON expr SEMCOLON CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [cond_st ::= (*) IF OPENPAR expr CLOSEPAR block ELSE block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [st ::= (*) RETURN expr SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [type ::= (*) FLOAT , {ID }]
}
transition on DOUBLE to state [22]
transition on REPEAT to state [143]
transition on VOID to state [21]
transition on FOR to state [142]
transition on dclst to state [141]
transition on BOOL to state [20]
transition on variable to state [140]
transition on dcl to state [139]
transition on cond_st to state [138]
transition on CONST to state [17]
transition on assignment to state [137]
transition on st to state [136]
transition on BREAK to state [135]
transition on FOREACH to state [134]
transition on AUTO to state [15]
transition on FLOAT to state [14]
transition on loop_st to state [133]
transition on STRING to state [13]
transition on ID to state [132]
transition on IF to state [131]
transition on SWITCH to state [130]
transition on RETURN to state [129]
transition on CHAR to state [5]
transition on type to state [6]
transition on INT to state [3]
transition on CONTINUE to state [128]
transition on LONG to state [2]
transition on method_call to state [127]

-------------------
lalr_state [126]: {
  [func_dcl ::= FUNCTION type ID OPENPAR args CLOSEPAR block (*) , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
}

-------------------
lalr_state [127]: {
  [st ::= method_call (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}

-------------------
lalr_state [128]: {
  [st ::= CONTINUE (*) SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on SEMCOLON to state [227]

-------------------
lalr_state [129]: {
  [expr ::= (*) expr OR expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {SEMCOLON DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [st ::= RETURN (*) SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [const_val ::= (*) CHAR_CONST , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {SEMCOLON DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {SEMCOLON DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [st ::= RETURN (*) expr SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [const_val ::= (*) REAL_CONST , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on CHAR_CONST to state [46]
transition on const_val to state [36]
transition on LONG_CONST to state [33]
transition on variable to state [42]
transition on MINMIN to state [49]
transition on MINUS to state [34]
transition on PLUSPLUS to state [38]
transition on SEMCOLON to state [225]
transition on REAL_CONST to state [35]
transition on INT_CONST to state [39]
transition on OPENPAR to state [40]
transition on TILDE to state [43]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on NOT to state [47]
transition on expr to state [224]
transition on STRING_CONST to state [41]
transition on SIZEOF to state [37]

-------------------
lalr_state [130]: {
  [cond_st ::= SWITCH (*) OPENPAR expr CLOSEPAR OF COLON BEGIN cases DEFAULT COLON block END , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on OPENPAR to state [208]

-------------------
lalr_state [131]: {
  [cond_st ::= IF (*) OPENPAR expr CLOSEPAR block ELSE block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [cond_st ::= IF (*) OPENPAR expr CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on OPENPAR to state [202]

-------------------
lalr_state [132]: {
  [method_call ::= ID (*) OPENPAR params CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [array ::= (*) OPENBRAC expr CLOSEBRAC array , {EQ PLUSEQ MINUSEQ MULTEQ DIVEQ DOT }]
  [variable ::= ID (*) , {EQ PLUSEQ MINUSEQ MULTEQ DIVEQ DOT }]
  [method_call ::= ID (*) OPENPAR CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [variable ::= ID (*) array , {EQ PLUSEQ MINUSEQ MULTEQ DIVEQ DOT }]
  [type ::= ID (*) , {ID }]
  [array ::= (*) OPENBRAC expr CLOSEBRAC , {EQ PLUSEQ MINUSEQ MULTEQ DIVEQ DOT }]
}
transition on array to state [86]
transition on OPENPAR to state [195]
transition on OPENBRAC to state [30]

-------------------
lalr_state [133]: {
  [st ::= loop_st (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}

-------------------
lalr_state [134]: {
  [loop_st ::= FOREACH (*) OPENPAR ID IN ID CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on OPENPAR to state [189]

-------------------
lalr_state [135]: {
  [st ::= BREAK (*) SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on SEMCOLON to state [188]

-------------------
lalr_state [136]: {
  [assignment ::= (*) variable MINUSEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= (*) FOR OPENPAR assignment SEMCOLON expr SEMCOLON assignment CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [method_call ::= (*) ID OPENPAR CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [st ::= (*) method_call , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [type ::= (*) STRING , {ID }]
  [variable ::= (*) ID , {EQ PLUSEQ MINUSEQ MULTEQ DIVEQ DOT }]
  [loop_st ::= (*) REPEAT block UNTIL OPENPAR expr CLOSEPAR SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [cond_st ::= (*) SWITCH OPENPAR expr CLOSEPAR OF COLON BEGIN cases DEFAULT COLON block END , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [st ::= (*) RETURN SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [type ::= (*) LONG , {ID }]
  [assignment ::= (*) variable MULTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= (*) FOR OPENPAR assignment SEMCOLON expr SEMCOLON CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [st ::= (*) assignment , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [type ::= (*) VOID , {ID }]
  [variable ::= (*) variable DOT ID , {EQ PLUSEQ MINUSEQ MULTEQ DIVEQ DOT }]
  [loop_st ::= (*) FOREACH OPENPAR ID IN ID CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [st ::= (*) BREAK SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [dclst ::= (*) dcl dclst , {END }]
  [type ::= (*) CHAR , {ID }]
  [assignment ::= (*) variable DIVEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= (*) FOR OPENPAR SEMCOLON expr SEMCOLON expr CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [st ::= (*) cond_st , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [type ::= (*) AUTO , {ID }]
  [type ::= (*) INT , {ID }]
  [variable ::= (*) ID array , {EQ PLUSEQ MINUSEQ MULTEQ DIVEQ DOT }]
  [assignment ::= (*) variable EQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [dclst ::= st (*) dclst , {END }]
  [st ::= (*) CONTINUE SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [dclst ::= (*) st dclst , {END }]
  [dcl ::= (*) type commadcls SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [type ::= (*) DOUBLE , {ID }]
  [loop_st ::= (*) FOR OPENPAR SEMCOLON expr SEMCOLON assignment CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [cond_st ::= (*) IF OPENPAR expr CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [st ::= (*) loop_st , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [type ::= (*) BOOL , {ID }]
  [assignment ::= (*) variable PLUSEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= (*) FOR OPENPAR assignment SEMCOLON expr SEMCOLON expr CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [method_call ::= (*) ID OPENPAR params CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [dclst ::= (*) , {END }]
  [dcl ::= (*) CONST type commadcls SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [type ::= (*) ID , {ID }]
  [loop_st ::= (*) FOR OPENPAR SEMCOLON expr SEMCOLON CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [cond_st ::= (*) IF OPENPAR expr CLOSEPAR block ELSE block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [st ::= (*) RETURN expr SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [type ::= (*) FLOAT , {ID }]
}
transition on DOUBLE to state [22]
transition on REPEAT to state [143]
transition on VOID to state [21]
transition on FOR to state [142]
transition on dclst to state [187]
transition on BOOL to state [20]
transition on variable to state [140]
transition on dcl to state [139]
transition on cond_st to state [138]
transition on CONST to state [17]
transition on assignment to state [137]
transition on st to state [136]
transition on BREAK to state [135]
transition on AUTO to state [15]
transition on FOREACH to state [134]
transition on FLOAT to state [14]
transition on loop_st to state [133]
transition on STRING to state [13]
transition on ID to state [132]
transition on IF to state [131]
transition on SWITCH to state [130]
transition on RETURN to state [129]
transition on CHAR to state [5]
transition on type to state [6]
transition on INT to state [3]
transition on CONTINUE to state [128]
transition on LONG to state [2]
transition on method_call to state [127]

-------------------
lalr_state [137]: {
  [st ::= assignment (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}

-------------------
lalr_state [138]: {
  [st ::= cond_st (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}

-------------------
lalr_state [139]: {
  [assignment ::= (*) variable MINUSEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= (*) FOR OPENPAR assignment SEMCOLON expr SEMCOLON assignment CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [method_call ::= (*) ID OPENPAR CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [st ::= (*) method_call , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [type ::= (*) STRING , {ID }]
  [variable ::= (*) ID , {EQ PLUSEQ MINUSEQ MULTEQ DIVEQ DOT }]
  [loop_st ::= (*) REPEAT block UNTIL OPENPAR expr CLOSEPAR SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [cond_st ::= (*) SWITCH OPENPAR expr CLOSEPAR OF COLON BEGIN cases DEFAULT COLON block END , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [st ::= (*) RETURN SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [type ::= (*) LONG , {ID }]
  [assignment ::= (*) variable MULTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= (*) FOR OPENPAR assignment SEMCOLON expr SEMCOLON CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [st ::= (*) assignment , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [type ::= (*) VOID , {ID }]
  [variable ::= (*) variable DOT ID , {EQ PLUSEQ MINUSEQ MULTEQ DIVEQ DOT }]
  [loop_st ::= (*) FOREACH OPENPAR ID IN ID CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [st ::= (*) BREAK SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [dclst ::= dcl (*) dclst , {END }]
  [dclst ::= (*) dcl dclst , {END }]
  [type ::= (*) CHAR , {ID }]
  [assignment ::= (*) variable DIVEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= (*) FOR OPENPAR SEMCOLON expr SEMCOLON expr CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [st ::= (*) cond_st , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [type ::= (*) AUTO , {ID }]
  [type ::= (*) INT , {ID }]
  [variable ::= (*) ID array , {EQ PLUSEQ MINUSEQ MULTEQ DIVEQ DOT }]
  [assignment ::= (*) variable EQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [st ::= (*) CONTINUE SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [dclst ::= (*) st dclst , {END }]
  [dcl ::= (*) type commadcls SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [type ::= (*) DOUBLE , {ID }]
  [loop_st ::= (*) FOR OPENPAR SEMCOLON expr SEMCOLON assignment CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [cond_st ::= (*) IF OPENPAR expr CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [st ::= (*) loop_st , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [type ::= (*) BOOL , {ID }]
  [assignment ::= (*) variable PLUSEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= (*) FOR OPENPAR assignment SEMCOLON expr SEMCOLON expr CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [method_call ::= (*) ID OPENPAR params CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [dclst ::= (*) , {END }]
  [dcl ::= (*) CONST type commadcls SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [type ::= (*) ID , {ID }]
  [loop_st ::= (*) FOR OPENPAR SEMCOLON expr SEMCOLON CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [cond_st ::= (*) IF OPENPAR expr CLOSEPAR block ELSE block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [st ::= (*) RETURN expr SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [type ::= (*) FLOAT , {ID }]
}
transition on DOUBLE to state [22]
transition on REPEAT to state [143]
transition on VOID to state [21]
transition on FOR to state [142]
transition on dclst to state [186]
transition on BOOL to state [20]
transition on variable to state [140]
transition on dcl to state [139]
transition on cond_st to state [138]
transition on CONST to state [17]
transition on assignment to state [137]
transition on st to state [136]
transition on BREAK to state [135]
transition on FOREACH to state [134]
transition on AUTO to state [15]
transition on FLOAT to state [14]
transition on loop_st to state [133]
transition on STRING to state [13]
transition on ID to state [132]
transition on IF to state [131]
transition on SWITCH to state [130]
transition on RETURN to state [129]
transition on CHAR to state [5]
transition on type to state [6]
transition on INT to state [3]
transition on CONTINUE to state [128]
transition on LONG to state [2]
transition on method_call to state [127]

-------------------
lalr_state [140]: {
  [variable ::= variable (*) DOT ID , {EQ PLUSEQ MINUSEQ MULTEQ DIVEQ DOT }]
  [assignment ::= variable (*) MINUSEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH }]
  [assignment ::= variable (*) DIVEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH }]
  [assignment ::= variable (*) PLUSEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH }]
  [assignment ::= variable (*) MULTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH }]
  [assignment ::= variable (*) EQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH }]
}
transition on DOT to state [51]
transition on MINUSEQ to state [164]
transition on MULTEQ to state [163]
transition on PLUSEQ to state [162]
transition on EQ to state [161]
transition on DIVEQ to state [160]

-------------------
lalr_state [141]: {
  [block ::= BEGIN dclst (*) END , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD RETURN BREAK CONTINUE IF ELSE SWITCH END DEFAULT CASE FOR REPEAT UNTIL FOREACH }]
}
transition on END to state [185]

-------------------
lalr_state [142]: {
  [loop_st ::= FOR (*) OPENPAR assignment SEMCOLON expr SEMCOLON CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= FOR (*) OPENPAR SEMCOLON expr SEMCOLON assignment CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= FOR (*) OPENPAR assignment SEMCOLON expr SEMCOLON assignment CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= FOR (*) OPENPAR SEMCOLON expr SEMCOLON expr CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= FOR (*) OPENPAR assignment SEMCOLON expr SEMCOLON expr CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= FOR (*) OPENPAR SEMCOLON expr SEMCOLON CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on OPENPAR to state [150]

-------------------
lalr_state [143]: {
  [block ::= (*) BEGIN dclst END , {UNTIL }]
  [loop_st ::= REPEAT (*) block UNTIL OPENPAR expr CLOSEPAR SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on block to state [144]
transition on BEGIN to state [125]

-------------------
lalr_state [144]: {
  [loop_st ::= REPEAT block (*) UNTIL OPENPAR expr CLOSEPAR SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on UNTIL to state [145]

-------------------
lalr_state [145]: {
  [loop_st ::= REPEAT block UNTIL (*) OPENPAR expr CLOSEPAR SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on OPENPAR to state [146]

-------------------
lalr_state [146]: {
  [expr ::= (*) expr OR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [loop_st ::= REPEAT block UNTIL OPENPAR (*) expr CLOSEPAR SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [variable ::= (*) ID , {CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [147]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [147]: {
  [expr ::= expr (*) OR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [loop_st ::= REPEAT block UNTIL OPENPAR expr (*) CLOSEPAR SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [expr ::= expr (*) MULT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on CLOSEPAR to state [148]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [148]: {
  [loop_st ::= REPEAT block UNTIL OPENPAR expr CLOSEPAR (*) SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on SEMCOLON to state [149]

-------------------
lalr_state [149]: {
  [loop_st ::= REPEAT block UNTIL OPENPAR expr CLOSEPAR SEMCOLON (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}

-------------------
lalr_state [150]: {
  [assignment ::= (*) variable EQ expr , {SEMCOLON }]
  [loop_st ::= FOR OPENPAR (*) assignment SEMCOLON expr SEMCOLON CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [variable ::= (*) ID , {EQ PLUSEQ MINUSEQ MULTEQ DIVEQ DOT }]
  [assignment ::= (*) variable MINUSEQ expr , {SEMCOLON }]
  [loop_st ::= FOR OPENPAR (*) SEMCOLON expr SEMCOLON assignment CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= FOR OPENPAR (*) assignment SEMCOLON expr SEMCOLON assignment CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [variable ::= (*) ID array , {EQ PLUSEQ MINUSEQ MULTEQ DIVEQ DOT }]
  [assignment ::= (*) variable DIVEQ expr , {SEMCOLON }]
  [assignment ::= (*) variable PLUSEQ expr , {SEMCOLON }]
  [loop_st ::= FOR OPENPAR (*) SEMCOLON expr SEMCOLON expr CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= FOR OPENPAR (*) assignment SEMCOLON expr SEMCOLON expr CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [variable ::= (*) variable DOT ID , {EQ PLUSEQ MINUSEQ MULTEQ DIVEQ DOT }]
  [loop_st ::= FOR OPENPAR (*) SEMCOLON expr SEMCOLON CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [assignment ::= (*) variable MULTEQ expr , {SEMCOLON }]
}
transition on assignment to state [152]
transition on SEMCOLON to state [151]
transition on variable to state [140]
transition on ID to state [45]

-------------------
lalr_state [151]: {
  [expr ::= (*) expr OR expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {SEMCOLON DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {SEMCOLON DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [loop_st ::= FOR OPENPAR SEMCOLON (*) expr SEMCOLON expr CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [expr ::= (*) MINUS expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {SEMCOLON DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [loop_st ::= FOR OPENPAR SEMCOLON (*) expr SEMCOLON assignment CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [expr ::= (*) TILDE expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [loop_st ::= FOR OPENPAR SEMCOLON (*) expr SEMCOLON CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [expr ::= (*) NOT expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [175]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [152]: {
  [loop_st ::= FOR OPENPAR assignment (*) SEMCOLON expr SEMCOLON assignment CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= FOR OPENPAR assignment (*) SEMCOLON expr SEMCOLON expr CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= FOR OPENPAR assignment (*) SEMCOLON expr SEMCOLON CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on SEMCOLON to state [153]

-------------------
lalr_state [153]: {
  [expr ::= (*) expr OR expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {SEMCOLON DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [loop_st ::= FOR OPENPAR assignment SEMCOLON (*) expr SEMCOLON CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {SEMCOLON DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {SEMCOLON DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [loop_st ::= FOR OPENPAR assignment SEMCOLON (*) expr SEMCOLON expr CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [expr ::= (*) expr AND expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [loop_st ::= FOR OPENPAR assignment SEMCOLON (*) expr SEMCOLON assignment CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [154]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [154]: {
  [expr ::= expr (*) MINUS expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [loop_st ::= FOR OPENPAR assignment SEMCOLON expr (*) SEMCOLON CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [expr ::= expr (*) ARITOR expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [loop_st ::= FOR OPENPAR assignment SEMCOLON expr (*) SEMCOLON expr CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [expr ::= expr (*) AND expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [loop_st ::= FOR OPENPAR assignment SEMCOLON expr (*) SEMCOLON assignment CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [expr ::= expr (*) OR expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on SEMCOLON to state [155]
transition on GTEQ to state [58]
transition on XOR to state [56]
transition on EQEQ to state [57]
transition on AND to state [55]
transition on MINUS to state [53]
transition on ARITAND to state [54]

-------------------
lalr_state [155]: {
  [expr ::= (*) expr OR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [assignment ::= (*) variable MINUSEQ expr , {CLOSEPAR }]
  [variable ::= (*) ID , {EQ PLUSEQ MINUSEQ MULTEQ DIVEQ CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [loop_st ::= FOR OPENPAR assignment SEMCOLON expr SEMCOLON (*) CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [const_val ::= (*) CHAR_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [assignment ::= (*) variable MULTEQ expr , {CLOSEPAR }]
  [variable ::= (*) variable DOT ID , {EQ PLUSEQ MINUSEQ MULTEQ DIVEQ CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [assignment ::= (*) variable DIVEQ expr , {CLOSEPAR }]
  [variable ::= (*) ID array , {EQ PLUSEQ MINUSEQ MULTEQ DIVEQ CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [assignment ::= (*) variable EQ expr , {CLOSEPAR }]
  [const_val ::= (*) STRING_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [loop_st ::= FOR OPENPAR assignment SEMCOLON expr SEMCOLON (*) expr CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [const_val ::= (*) INT_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [assignment ::= (*) variable PLUSEQ expr , {CLOSEPAR }]
  [const_val ::= (*) LONG_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [loop_st ::= FOR OPENPAR assignment SEMCOLON expr SEMCOLON (*) assignment CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [const_val ::= (*) REAL_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on CHAR_CONST to state [46]
transition on const_val to state [36]
transition on LONG_CONST to state [33]
transition on variable to state [159]
transition on MINMIN to state [49]
transition on MINUS to state [34]
transition on assignment to state [158]
transition on PLUSPLUS to state [38]
transition on REAL_CONST to state [35]
transition on INT_CONST to state [39]
transition on OPENPAR to state [40]
transition on TILDE to state [43]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on CLOSEPAR to state [157]
transition on NOT to state [47]
transition on expr to state [156]
transition on STRING_CONST to state [41]
transition on SIZEOF to state [37]

-------------------
lalr_state [156]: {
  [expr ::= expr (*) OR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [loop_st ::= FOR OPENPAR assignment SEMCOLON expr SEMCOLON expr (*) CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [expr ::= expr (*) MULT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on CLOSEPAR to state [173]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [157]: {
  [block ::= (*) BEGIN dclst END , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= FOR OPENPAR assignment SEMCOLON expr SEMCOLON CLOSEPAR (*) block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on block to state [172]
transition on BEGIN to state [125]

-------------------
lalr_state [158]: {
  [loop_st ::= FOR OPENPAR assignment SEMCOLON expr SEMCOLON assignment (*) CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on CLOSEPAR to state [170]

-------------------
lalr_state [159]: {
  [expr ::= variable (*) MINMIN , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [assignment ::= variable (*) MINUSEQ expr , {CLOSEPAR }]
  [expr ::= variable (*) , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [assignment ::= variable (*) DIVEQ expr , {CLOSEPAR }]
  [assignment ::= variable (*) PLUSEQ expr , {CLOSEPAR }]
  [variable ::= variable (*) DOT ID , {EQ PLUSEQ MINUSEQ MULTEQ DIVEQ CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [assignment ::= variable (*) MULTEQ expr , {CLOSEPAR }]
  [expr ::= variable (*) PLUSPLUS , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [assignment ::= variable (*) EQ expr , {CLOSEPAR }]
}
transition on DOT to state [51]
transition on MINMIN to state [88]
transition on PLUSPLUS to state [89]
transition on MINUSEQ to state [164]
transition on MULTEQ to state [163]
transition on PLUSEQ to state [162]
transition on EQ to state [161]
transition on DIVEQ to state [160]

-------------------
lalr_state [160]: {
  [expr ::= (*) expr OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [assignment ::= variable DIVEQ (*) expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR }]
  [expr ::= (*) expr EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [169]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [161]: {
  [expr ::= (*) expr OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [assignment ::= variable EQ (*) expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR }]
  [expr ::= (*) expr ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [168]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [162]: {
  [expr ::= (*) expr OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [assignment ::= variable PLUSEQ (*) expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR }]
  [expr ::= (*) expr ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [167]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [163]: {
  [expr ::= (*) expr OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [assignment ::= variable MULTEQ (*) expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [166]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [164]: {
  [expr ::= (*) expr OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [assignment ::= variable MINUSEQ (*) expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR }]
  [expr ::= (*) expr MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [165]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [165]: {
  [expr ::= expr (*) OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [assignment ::= variable MINUSEQ expr (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR }]
  [expr ::= expr (*) DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [166]: {
  [expr ::= expr (*) OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [assignment ::= variable MULTEQ expr (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR }]
  [expr ::= expr (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [167]: {
  [expr ::= expr (*) OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [assignment ::= variable PLUSEQ expr (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR }]
  [expr ::= expr (*) MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [168]: {
  [expr ::= expr (*) OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [assignment ::= variable EQ expr (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [169]: {
  [expr ::= expr (*) OR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [assignment ::= variable DIVEQ expr (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR }]
  [expr ::= expr (*) MULT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR SEMCOLON REPEAT FOREACH CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [170]: {
  [block ::= (*) BEGIN dclst END , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= FOR OPENPAR assignment SEMCOLON expr SEMCOLON assignment CLOSEPAR (*) block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on block to state [171]
transition on BEGIN to state [125]

-------------------
lalr_state [171]: {
  [loop_st ::= FOR OPENPAR assignment SEMCOLON expr SEMCOLON assignment CLOSEPAR block (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}

-------------------
lalr_state [172]: {
  [loop_st ::= FOR OPENPAR assignment SEMCOLON expr SEMCOLON CLOSEPAR block (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}

-------------------
lalr_state [173]: {
  [loop_st ::= FOR OPENPAR assignment SEMCOLON expr SEMCOLON expr CLOSEPAR (*) block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [block ::= (*) BEGIN dclst END , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on block to state [174]
transition on BEGIN to state [125]

-------------------
lalr_state [174]: {
  [loop_st ::= FOR OPENPAR assignment SEMCOLON expr SEMCOLON expr CLOSEPAR block (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}

-------------------
lalr_state [175]: {
  [expr ::= expr (*) MINUS expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [loop_st ::= FOR OPENPAR SEMCOLON expr (*) SEMCOLON CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [expr ::= expr (*) MULT expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [loop_st ::= FOR OPENPAR SEMCOLON expr (*) SEMCOLON expr CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [expr ::= expr (*) PLUS expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) OR expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [loop_st ::= FOR OPENPAR SEMCOLON expr (*) SEMCOLON assignment CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on SEMCOLON to state [176]
transition on GTEQ to state [58]
transition on XOR to state [56]
transition on EQEQ to state [57]
transition on AND to state [55]
transition on MINUS to state [53]
transition on ARITAND to state [54]

-------------------
lalr_state [176]: {
  [expr ::= (*) expr OR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [assignment ::= (*) variable MINUSEQ expr , {CLOSEPAR }]
  [variable ::= (*) ID , {EQ PLUSEQ MINUSEQ MULTEQ DIVEQ CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [assignment ::= (*) variable MULTEQ expr , {CLOSEPAR }]
  [variable ::= (*) variable DOT ID , {EQ PLUSEQ MINUSEQ MULTEQ DIVEQ CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [loop_st ::= FOR OPENPAR SEMCOLON expr SEMCOLON (*) expr CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [expr ::= (*) const_val , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [assignment ::= (*) variable DIVEQ expr , {CLOSEPAR }]
  [variable ::= (*) ID array , {EQ PLUSEQ MINUSEQ MULTEQ DIVEQ CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [assignment ::= (*) variable EQ expr , {CLOSEPAR }]
  [const_val ::= (*) STRING_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [loop_st ::= FOR OPENPAR SEMCOLON expr SEMCOLON (*) assignment CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [expr ::= (*) TILDE expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [assignment ::= (*) variable PLUSEQ expr , {CLOSEPAR }]
  [const_val ::= (*) LONG_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [loop_st ::= FOR OPENPAR SEMCOLON expr SEMCOLON (*) CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [expr ::= (*) NOT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on CHAR_CONST to state [46]
transition on const_val to state [36]
transition on LONG_CONST to state [33]
transition on variable to state [159]
transition on MINMIN to state [49]
transition on MINUS to state [34]
transition on PLUSPLUS to state [38]
transition on assignment to state [179]
transition on REAL_CONST to state [35]
transition on INT_CONST to state [39]
transition on OPENPAR to state [40]
transition on TILDE to state [43]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on CLOSEPAR to state [178]
transition on NOT to state [47]
transition on expr to state [177]
transition on STRING_CONST to state [41]
transition on SIZEOF to state [37]

-------------------
lalr_state [177]: {
  [expr ::= expr (*) OR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [loop_st ::= FOR OPENPAR SEMCOLON expr SEMCOLON expr (*) CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [expr ::= expr (*) MULT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on CLOSEPAR to state [183]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [178]: {
  [block ::= (*) BEGIN dclst END , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= FOR OPENPAR SEMCOLON expr SEMCOLON CLOSEPAR (*) block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on block to state [182]
transition on BEGIN to state [125]

-------------------
lalr_state [179]: {
  [loop_st ::= FOR OPENPAR SEMCOLON expr SEMCOLON assignment (*) CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on CLOSEPAR to state [180]

-------------------
lalr_state [180]: {
  [block ::= (*) BEGIN dclst END , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= FOR OPENPAR SEMCOLON expr SEMCOLON assignment CLOSEPAR (*) block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on block to state [181]
transition on BEGIN to state [125]

-------------------
lalr_state [181]: {
  [loop_st ::= FOR OPENPAR SEMCOLON expr SEMCOLON assignment CLOSEPAR block (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}

-------------------
lalr_state [182]: {
  [loop_st ::= FOR OPENPAR SEMCOLON expr SEMCOLON CLOSEPAR block (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}

-------------------
lalr_state [183]: {
  [loop_st ::= FOR OPENPAR SEMCOLON expr SEMCOLON expr CLOSEPAR (*) block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [block ::= (*) BEGIN dclst END , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on block to state [184]
transition on BEGIN to state [125]

-------------------
lalr_state [184]: {
  [loop_st ::= FOR OPENPAR SEMCOLON expr SEMCOLON expr CLOSEPAR block (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}

-------------------
lalr_state [185]: {
  [block ::= BEGIN dclst END (*) , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD RETURN BREAK CONTINUE IF ELSE SWITCH END DEFAULT CASE FOR REPEAT UNTIL FOREACH }]
}

-------------------
lalr_state [186]: {
  [dclst ::= dcl dclst (*) , {END }]
}

-------------------
lalr_state [187]: {
  [dclst ::= st dclst (*) , {END }]
}

-------------------
lalr_state [188]: {
  [st ::= BREAK SEMCOLON (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}

-------------------
lalr_state [189]: {
  [loop_st ::= FOREACH OPENPAR (*) ID IN ID CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on ID to state [190]

-------------------
lalr_state [190]: {
  [loop_st ::= FOREACH OPENPAR ID (*) IN ID CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on IN to state [191]

-------------------
lalr_state [191]: {
  [loop_st ::= FOREACH OPENPAR ID IN (*) ID CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on ID to state [192]

-------------------
lalr_state [192]: {
  [loop_st ::= FOREACH OPENPAR ID IN ID (*) CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on CLOSEPAR to state [193]

-------------------
lalr_state [193]: {
  [block ::= (*) BEGIN dclst END , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [loop_st ::= FOREACH OPENPAR ID IN ID CLOSEPAR (*) block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on block to state [194]
transition on BEGIN to state [125]

-------------------
lalr_state [194]: {
  [loop_st ::= FOREACH OPENPAR ID IN ID CLOSEPAR block (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}

-------------------
lalr_state [195]: {
  [expr ::= (*) expr OR expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [method_call ::= ID OPENPAR (*) CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [variable ::= (*) ID , {COMMA CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [params ::= (*) expr , {CLOSEPAR }]
  [variable ::= (*) variable DOT ID , {COMMA CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [params ::= (*) expr COMMA params , {CLOSEPAR }]
  [variable ::= (*) ID array , {COMMA CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [method_call ::= ID OPENPAR (*) params CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [const_val ::= (*) LONG_CONST , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on CHAR_CONST to state [46]
transition on params to state [198]
transition on const_val to state [36]
transition on LONG_CONST to state [33]
transition on variable to state [42]
transition on MINMIN to state [49]
transition on MINUS to state [34]
transition on PLUSPLUS to state [38]
transition on REAL_CONST to state [35]
transition on INT_CONST to state [39]
transition on OPENPAR to state [40]
transition on TILDE to state [43]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on CLOSEPAR to state [197]
transition on NOT to state [47]
transition on expr to state [196]
transition on STRING_CONST to state [41]
transition on SIZEOF to state [37]

-------------------
lalr_state [196]: {
  [expr ::= expr (*) MINUS expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [params ::= expr (*) , {CLOSEPAR }]
  [expr ::= expr (*) PLUS expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) OR expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [params ::= expr (*) COMMA params , {CLOSEPAR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on COMMA to state [200]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on GTEQ to state [58]
transition on XOR to state [56]
transition on EQEQ to state [57]
transition on AND to state [55]
transition on MINUS to state [53]
transition on ARITAND to state [54]

-------------------
lalr_state [197]: {
  [method_call ::= ID OPENPAR CLOSEPAR (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}

-------------------
lalr_state [198]: {
  [method_call ::= ID OPENPAR params (*) CLOSEPAR , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on CLOSEPAR to state [199]

-------------------
lalr_state [199]: {
  [method_call ::= ID OPENPAR params CLOSEPAR (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}

-------------------
lalr_state [200]: {
  [expr ::= (*) expr OR expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {COMMA CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [params ::= (*) expr , {CLOSEPAR }]
  [variable ::= (*) variable DOT ID , {COMMA CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [params ::= expr COMMA (*) params , {CLOSEPAR }]
  [params ::= (*) expr COMMA params , {CLOSEPAR }]
  [variable ::= (*) ID array , {COMMA CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {COMMA CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on CHAR_CONST to state [46]
transition on params to state [201]
transition on const_val to state [36]
transition on LONG_CONST to state [33]
transition on variable to state [42]
transition on MINMIN to state [49]
transition on MINUS to state [34]
transition on PLUSPLUS to state [38]
transition on REAL_CONST to state [35]
transition on INT_CONST to state [39]
transition on OPENPAR to state [40]
transition on TILDE to state [43]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on NOT to state [47]
transition on expr to state [196]
transition on STRING_CONST to state [41]
transition on SIZEOF to state [37]

-------------------
lalr_state [201]: {
  [params ::= expr COMMA params (*) , {CLOSEPAR }]
}

-------------------
lalr_state [202]: {
  [expr ::= (*) expr OR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) CHAR_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [cond_st ::= IF OPENPAR (*) expr CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [const_val ::= (*) INT_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [cond_st ::= IF OPENPAR (*) expr CLOSEPAR block ELSE block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [expr ::= (*) expr MINUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [203]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [203]: {
  [expr ::= expr (*) MINUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [cond_st ::= IF OPENPAR expr (*) CLOSEPAR block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [expr ::= expr (*) MULT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) OR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [cond_st ::= IF OPENPAR expr (*) CLOSEPAR block ELSE block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [expr ::= expr (*) DIV expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on CLOSEPAR to state [204]
transition on GTEQ to state [58]
transition on XOR to state [56]
transition on EQEQ to state [57]
transition on AND to state [55]
transition on MINUS to state [53]
transition on ARITAND to state [54]

-------------------
lalr_state [204]: {
  [cond_st ::= IF OPENPAR expr CLOSEPAR (*) block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [block ::= (*) BEGIN dclst END , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF ELSE SWITCH END FOR REPEAT FOREACH }]
  [cond_st ::= IF OPENPAR expr CLOSEPAR (*) block ELSE block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on block to state [205]
transition on BEGIN to state [125]

-------------------
lalr_state [205]: {
  [cond_st ::= IF OPENPAR expr CLOSEPAR block (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [cond_st ::= IF OPENPAR expr CLOSEPAR block (*) ELSE block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on ELSE to state [206]

-------------------
lalr_state [206]: {
  [block ::= (*) BEGIN dclst END , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [cond_st ::= IF OPENPAR expr CLOSEPAR block ELSE (*) block , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on block to state [207]
transition on BEGIN to state [125]

-------------------
lalr_state [207]: {
  [cond_st ::= IF OPENPAR expr CLOSEPAR block ELSE block (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}

-------------------
lalr_state [208]: {
  [expr ::= (*) expr OR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MOD expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID , {CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable MINMIN , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LTEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MULT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [cond_st ::= SWITCH OPENPAR (*) expr CLOSEPAR OF COLON BEGIN cases DEFAULT COLON block END , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [const_val ::= (*) CHAR_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) OPENPAR expr CLOSEPAR , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr XOR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) variable DOT ID , {CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) variable PLUSPLUS , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr DIV expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) BOOL_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) const_val , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr EQEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [variable ::= (*) ID array , {CLOSEPAR DOT MINMIN PLUSPLUS PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) MINMIN variable , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr LT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITOR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) STRING_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) TILDE expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr INEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr PLUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) INT_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) PLUSPLUS variable , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr AND expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr ARITAND expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) LONG_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) NOT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr GTEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) expr MINUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [const_val ::= (*) REAL_CONST , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= (*) SIZEOF OPENPAR type CLOSEPAR , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on MINMIN to state [49]
transition on expr to state [209]
transition on NOT to state [47]
transition on CHAR_CONST to state [46]
transition on ID to state [45]
transition on BOOL_CONST to state [44]
transition on TILDE to state [43]
transition on variable to state [42]
transition on STRING_CONST to state [41]
transition on OPENPAR to state [40]
transition on INT_CONST to state [39]
transition on PLUSPLUS to state [38]
transition on SIZEOF to state [37]
transition on const_val to state [36]
transition on REAL_CONST to state [35]
transition on MINUS to state [34]
transition on LONG_CONST to state [33]

-------------------
lalr_state [209]: {
  [expr ::= expr (*) OR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) PLUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [cond_st ::= SWITCH OPENPAR expr (*) CLOSEPAR OF COLON BEGIN cases DEFAULT COLON block END , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [expr ::= expr (*) GTEQ expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {CLOSEPAR PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on CLOSEPAR to state [210]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [210]: {
  [cond_st ::= SWITCH OPENPAR expr CLOSEPAR (*) OF COLON BEGIN cases DEFAULT COLON block END , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on OF to state [211]

-------------------
lalr_state [211]: {
  [cond_st ::= SWITCH OPENPAR expr CLOSEPAR OF (*) COLON BEGIN cases DEFAULT COLON block END , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on COLON to state [212]

-------------------
lalr_state [212]: {
  [cond_st ::= SWITCH OPENPAR expr CLOSEPAR OF COLON (*) BEGIN cases DEFAULT COLON block END , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on BEGIN to state [213]

-------------------
lalr_state [213]: {
  [cases ::= (*) , {DEFAULT }]
  [cond_st ::= SWITCH OPENPAR expr CLOSEPAR OF COLON BEGIN (*) cases DEFAULT COLON block END , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [cases ::= (*) CASE INT_CONST COLON block cases , {DEFAULT }]
}
transition on CASE to state [215]
transition on cases to state [214]

-------------------
lalr_state [214]: {
  [cond_st ::= SWITCH OPENPAR expr CLOSEPAR OF COLON BEGIN cases (*) DEFAULT COLON block END , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on DEFAULT to state [220]

-------------------
lalr_state [215]: {
  [cases ::= CASE (*) INT_CONST COLON block cases , {DEFAULT }]
}
transition on INT_CONST to state [216]

-------------------
lalr_state [216]: {
  [cases ::= CASE INT_CONST (*) COLON block cases , {DEFAULT }]
}
transition on COLON to state [217]

-------------------
lalr_state [217]: {
  [cases ::= CASE INT_CONST COLON (*) block cases , {DEFAULT }]
  [block ::= (*) BEGIN dclst END , {DEFAULT CASE }]
}
transition on block to state [218]
transition on BEGIN to state [125]

-------------------
lalr_state [218]: {
  [cases ::= (*) , {DEFAULT }]
  [cases ::= CASE INT_CONST COLON block (*) cases , {DEFAULT }]
  [cases ::= (*) CASE INT_CONST COLON block cases , {DEFAULT }]
}
transition on CASE to state [215]
transition on cases to state [219]

-------------------
lalr_state [219]: {
  [cases ::= CASE INT_CONST COLON block cases (*) , {DEFAULT }]
}

-------------------
lalr_state [220]: {
  [cond_st ::= SWITCH OPENPAR expr CLOSEPAR OF COLON BEGIN cases DEFAULT (*) COLON block END , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on COLON to state [221]

-------------------
lalr_state [221]: {
  [cond_st ::= SWITCH OPENPAR expr CLOSEPAR OF COLON BEGIN cases DEFAULT COLON (*) block END , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [block ::= (*) BEGIN dclst END , {END }]
}
transition on block to state [222]
transition on BEGIN to state [125]

-------------------
lalr_state [222]: {
  [cond_st ::= SWITCH OPENPAR expr CLOSEPAR OF COLON BEGIN cases DEFAULT COLON block (*) END , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on END to state [223]

-------------------
lalr_state [223]: {
  [cond_st ::= SWITCH OPENPAR expr CLOSEPAR OF COLON BEGIN cases DEFAULT COLON block END (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}

-------------------
lalr_state [224]: {
  [expr ::= expr (*) OR expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GT expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) INEQ expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MOD expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) DIV expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [st ::= RETURN expr (*) SEMCOLON , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
  [expr ::= expr (*) PLUS expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) AND expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LTEQ expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) EQEQ expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITAND expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MULT expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) LT expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) GTEQ expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) XOR expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) ARITOR expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
  [expr ::= expr (*) MINUS expr , {SEMCOLON PLUS MINUS MULT DIV MOD ARITAND ARITOR XOR EQEQ INEQ GTEQ LTEQ GT LT AND OR }]
}
transition on OR to state [68]
transition on LTEQ to state [67]
transition on LT to state [66]
transition on ARITOR to state [65]
transition on GT to state [64]
transition on DIV to state [63]
transition on PLUS to state [62]
transition on INEQ to state [61]
transition on MOD to state [60]
transition on MULT to state [59]
transition on SEMCOLON to state [226]
transition on GTEQ to state [58]
transition on EQEQ to state [57]
transition on XOR to state [56]
transition on AND to state [55]
transition on ARITAND to state [54]
transition on MINUS to state [53]

-------------------
lalr_state [225]: {
  [st ::= RETURN SEMCOLON (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}

-------------------
lalr_state [226]: {
  [st ::= RETURN expr SEMCOLON (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}

-------------------
lalr_state [227]: {
  [st ::= CONTINUE SEMCOLON (*) , {ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}

-------------------
lalr_state [228]: {
  [func_dcl ::= FUNCTION type ID OPENPAR CLOSEPAR SEMCOLON (*) , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
}

-------------------
lalr_state [229]: {
  [func_dcl ::= FUNCTION type ID OPENPAR CLOSEPAR block (*) , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
}

-------------------
lalr_state [230]: {
  [dcl ::= type commadcls (*) SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}
transition on SEMCOLON to state [231]

-------------------
lalr_state [231]: {
  [dcl ::= type commadcls SEMCOLON (*) , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD RETURN BREAK CONTINUE IF SWITCH END FOR REPEAT FOREACH }]
}

-------------------
lalr_state [232]: {
  [extern_dcl ::= EXTERN type (*) ID SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
}
transition on ID to state [233]

-------------------
lalr_state [233]: {
  [extern_dcl ::= EXTERN type ID (*) SEMCOLON , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
}
transition on SEMCOLON to state [234]

-------------------
lalr_state [234]: {
  [extern_dcl ::= EXTERN type ID SEMCOLON (*) , {EOF EXTERN FUNCTION ID AUTO INT BOOL FLOAT LONG CHAR DOUBLE STRING VOID CONST RECORD }]
}

-------------------
------- CUP v0.11a beta 20060608 Parser Generation Summary -------
  0 errors and 0 warnings
  75 terminals, 26 non-terminals, and 109 productions declared, 
  producing 235 unique parse states.
  0 terminals declared but not used.
  0 non-terminals declared but not used.
  0 productions never reduced.
  0 conflicts detected (0 expected).
  Code written to "parser.java", and "sym.java".
---------------------------------------------------- (v0.11a beta 20060608)

package jflex;

import cup.sym;
import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.Symbol;
import java_cup.runtime.ComplexSymbolFactory.*;




/**
* This class is a lexer generated by Alireza Asadi on 2019/3/29.
*/

%%

%class MyScanner
%cup
%function next_token
%unicode
%char
%line
%column
%public

%{
    StringBuilder string = new StringBuilder();
    ComplexSymbolFactory symbolFactory;
    public MyScanner(java.io.Reader in, ComplexSymbolFactory sf){
	this(in);
	symbolFactory = sf;
    }

    private Symbol symbol(int sym) {
      return symbolFactory.newSymbol("sym", sym, new Location(yyline+1,yycolumn+1,yychar), new Location(yyline+1,yycolumn+yylength(),yychar+yylength()));
  }
  private Symbol symbol(int sym, Object val) {
      Location left = new Location(yyline+1,yycolumn+1,yychar);
      Location right= new Location(yyline+1,yycolumn+yylength(), yychar+yylength());
      return symbolFactory.newSymbol("sym", sym, left, right,val);
  }

%}


%eofval{
  return symbol(sym.EOF);
%eofval}

%init{
    //TODO
%init}



ALPHA=[A-Za-z]
HexAlpha = [a-fA-F]
DIGIT=[0-9]
Identifier = ({ALPHA}|_)({ALPHA}|{DIGIT}|_)*
Character = ('[^'\\]')
SpecialCharacter = "\\a"|"\\b"|"\\e"|"\\f"|"\\n"|"\\r"|"\\t"|
                    "\\v"|"\\'"|"\\\""|"\\?"
SpecialChar = ('{SpecialCharacter}')
SpecialString = [\t\n\r\"\\]
Postfix = u|U|l|L|"ul"|"UL"|"ll"|"LL"|"ull"|"ULL"
HexDecIntegerLiteral = ("0x" | "0X")({DIGIT} | {HexAlpha})+
BinDecIntegerLiteral = ("0b" | "0B")([01])+
OctDecIntegerLiteral = (0)([0-7])*
DecIntegerLiteral = 0 | [1-9][0-9]*
IntegerLiteral = (\+|-)?({HexDecIntegerLiteral} | {BinDecIntegerLiteral} |
                   {OctDecIntegerLiteral} | {DecIntegerLiteral})({Postfix})?
NormalRealLiteral = ({DecIntegerLiteral}?\.{DecIntegerLiteral}) |
                    ({DecIntegerLiteral}\.{DecIntegerLiteral}?)
SciRealLiteral = ({DecIntegerLiteral} | {NormalRealLiteral})(([eE](\+|-)?){DecIntegerLiteral})
RealLiteral = (\+|-)?({NormalRealLiteral} | {SciRealLiteral})(f|F)?
Literal = {IntegerLiteral} | {RealLiteral}
LineTerminator = \n | \r | \r\n
InputCharacter = [^\n\r]
WhiteSpace = [ \t\f] | {new_line}
BoolConst = ["false"|"true"]
new_line = \r|\n|\r\n
TC = "/*" [^*] ~"*/" | "/*" "*"+ "/"
EC = "//" [^\r\n]* {new_line}

%xstates String

%%


<YYINITIAL>{
    /* keywords */
    // "auto"				 { return symbol(sym.AUTO); }
    //"enum"				 { return symbol(sym.ENUM); }
    //"register"			 { return symbol(sym.REGISTER); }
    //"typedef"			 { return symbol(sym.TYPEDEF); }
    //"union"				 { return symbol(sym.UNION); }
    //"signed"			 { return symbol(sym.SIGNED); }
    //"static"			 { return symbol(sym.STATIC); }
    //"while"				 { return symbol(sym.WHILE); }
    //"goto"				 { return symbol(sym.GOTO); }
    //"volatile"			 { return symbol(sym.VOLATILE); }
    //"short"				 { return symbol(sym.SHORT); }
    //"unsigned"		     { return symbol(sym.UNSIGNED); }
    "double"			 { return symbol(sym.DOUBLE, "double"); }
    "bool"			     { return symbol(sym.BOOL, "bool"); }
    "int"				 { return symbol(sym.INT, "int"); }
    "record"			 { return symbol(sym.RECORD); }
    "break"				 { return symbol(sym.BREAK); }
    "else"				 { return symbol(sym.ELSE); }
    "long"				 { return symbol(sym.LONG, "long"); }
    "switch"			 { return symbol(sym.SWITCH); }
    "case"				 { return symbol(sym.CASE); }
    "char"				 { return symbol(sym.CHAR, "char"); }
    "extern"			 { return symbol(sym.EXTERN); }
    "return"			 { return symbol(sym.RETURN); }
    "continue"			 { return symbol(sym.CONTINUE); }
    "for"				 { return symbol(sym.FOR); }
    "void"				 { return symbol(sym.VOID, "void"); }
    "repeat"		     { return symbol(sym.REPEAT); }
    "if"				 { return symbol(sym.IF); }
    "until"			     { return symbol(sym.UNTIL); }
    "default"			 { return symbol(sym.DEFAULT); }
    "sizeof"			 { return symbol(sym.SIZEOF); }
    "const"				 { return symbol(sym.CONST); }
    "float"				 { return symbol(sym.FLOAT, "float"); }
    "string"		     { return symbol(sym.STRING, "string"); }
    ";"		             { return symbol(sym.SEMCOLON); }
    "("     		     { return symbol(sym.OPENPAR); }
    ")"        		     { return symbol(sym.CLOSEPAR); }
    "begin"        		 { return symbol(sym.BEGIN); }
    "end"        		 { return symbol(sym.END); }
    ","                  {return symbol(sym.COMMA);}
     "^"                 {return symbol(sym.XOR);}
     "not"               {return symbol(sym.NOT);}
     "~"                 {return symbol(sym.TILDE);}
     "."                    {return symbol(sym.DOT);}
     "and"                    {return symbol(sym.ARITAND);}
     "function"                    {return symbol(sym.FUNCTION);}
     "in"                    {return symbol(sym.IN);}
     "or"                    {return symbol(sym.ARITOR);}
     "of"                    {return symbol(sym.OF);}
     ":"                    {return symbol(sym.COLON);}
     "["                    {return symbol(sym.OPENBRAC);}
     "]"                    {return symbol(sym.CLOSEBRAC);}
     "auto"                    {return symbol(sym.AUTO, "auto");}
     "foreach"                    {return symbol(sym.FOREACH);}

    /* operators */
    "+"                  { return symbol(sym.PLUS); }
    "-"                  { return symbol(sym.MINUS); }
    "++"                 { return symbol(sym.PLUSPLUS); }
    "--"                 { return symbol(sym.MINMIN); }
    "="                  { return symbol(sym.EQ); }
    "=="                 { return symbol(sym.EQEQ); }
    "+="                 { return symbol(sym.PLUSEQ); }
    "/="                 {return symbol(sym.DIVEQ);}
    "*="                 {return symbol(sym.MULTEQ);}
    "-="                 { return symbol(sym.MINUSEQ); }
    "!="                 {return symbol(sym.INEQ);}
    "<="                 {return symbol(sym.LTEQ);}
    ">="                 {return symbol(sym.GTEQ);}
    "<"                 {return symbol(sym.LT);}

    /* identifiers */
    {Identifier}            { return symbol(sym.ID, yytext()); }


    /* literals */
    //bool
    {BoolConst}             {return symbol(sym.BOOL_CONST, Boolean.valueOf(yytext()));}
    //long
    {IntegerLiteral}("l"|"L") {return symbol(sym.LONG_CONST, Long.valueOf(yytext().substring(0, yytext().length() - 1)));}
    //integer
    {IntegerLiteral}        { return symbol(sym.INT_CONST, Integer.valueOf(yytext())); }
    //real
    {RealLiteral}           { return symbol(sym.REAL_CONST, Double.valueOf(yytext())); }

    /* characters */
    {Character}             { String str = yytext();
                                  str = str.substring(1, str.length() - 1);
                                  return symbol(sym.CHAR_CONST, str.charAt(0)); }

    /* Special characters */
    {SpecialChar}      {    String str = yytext();
                            if(yytext().length() > 1) // has single quotes
                                str = str.substring(1, str.length() - 1);
                           return symbol(sym.CHAR_CONST, str); }
    /* string constant */
    \"                  { string.setLength(0); yybegin(String); }

    /* whitespace */
    {WhiteSpace}            {}

    /*LineTerminator*/
    {LineTerminator}        {}
}

/* comments */
{EC}                    { }
{TC}                    { }

/* string */
<String>{
    \"                      { yybegin(YYINITIAL);
                              return symbol(sym.STRING_CONST, string.toString()); }
    [^\n\r\"\\]+            { string.append(yytext()); }
    \\t                     { string.append("\\t"); }
    \\n                     { string.append("\\n");}
    \\r                     { string.append("\\r"); }
    \\\"                    { string.append("\\\""); }
    \\                      { string.append("\\"); }
}


/* error fallback */
[^]                     { throw new Error("Illegal character <"+
                                            yytext()+">"); }



